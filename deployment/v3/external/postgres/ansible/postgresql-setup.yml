---
# PostgreSQL Setup with Secure Password Generation - Production Grade
# Enhanced playbook with secure password generation and Kubernetes secret creation

- name: PostgreSQL Secure Setup
  hosts: postgresql_servers
  become: yes
  vars:
    # Default configuration - easily overridable
    postgres_version: "{{ postgresql_version | default('15') }}"
    postgres_port: "{{ postgresql_port | default('5433') }}"
    postgres_device: "{{ storage_device | default('/dev/nvme2n1') }}"
    postgres_mount: "{{ mount_point | default('/srv/postgres') }}"
    postgres_data_dir: "{{ postgres_mount }}/postgresql/{{ postgres_version }}/main"
    postgres_old_dir: "{% if ansible_os_family == 'Debian' %}/var/lib/postgresql/{{ postgres_version }}/main{% else %}/var/lib/pgsql/{{ postgres_version }}/data{% endif %}"
    postgres_config_dir: "{% if ansible_os_family == 'Debian' %}/etc/postgresql/{{ postgres_version }}/main{% else %}/var/lib/pgsql/{{ postgres_version }}/data{% endif %}"
    postgres_bin_dir: "{% if ansible_os_family == 'Debian' %}/usr/lib/postgresql/{{ postgres_version }}/bin{% else %}/usr/pgsql-{{ postgres_version }}/bin{% endif %}"
    postgres_service_name: "{% if ansible_os_family == 'Debian' %}postgresql{% else %}postgresql-{{ postgres_version }}{% endif %}"
    postgres_network_cidr: "{{ network_cidr | default('10.0.0.0/8') }}"
    postgres_namespace: "{{ kubernetes_namespace | default('postgres') }}"
    postgres_secret_name: "{{ secret_name | default('postgres-postgresql') }}"
    # Use localhost for local operations, but actual IP for ConfigMap
    postgres_local_host: "{{ local_connection_host | default('localhost') }}"
    postgres_external_host: "{{ ansible_host }}"
    
  tasks:
    # OS Compatibility and Prerequisites
    - name: Gather OS facts
      setup:
        gather_subset: 
          - 'distribution'
          - 'distribution_version'
    
    - name: Ensure Python3 is available (CentOS/RHEL compatibility)
      package:
        name: python3
        state: present
      when: ansible_os_family == "RedHat"
      become: yes
    
    - name: Verify Python3 with secrets module availability
      command: python3 -c "import secrets; print('Python secrets module available')"
      register: python_secrets_check
      failed_when: python_secrets_check.rc != 0
      changed_when: false
    
    # Prerequisites Check
    - name: Check if device exists
      stat:
        path: "{{ postgres_device }}"
      register: device_check
      failed_when: not device_check.stat.exists
      
    # Secure Password Generation - Idempotent approach
    - name: Check if PostgreSQL is already configured with a password
      shell: |
        sudo -u postgres psql -p {{ postgres_port }} -c "SELECT 1;" 2>/dev/null
      register: postgres_status_check
      failed_when: false
      changed_when: false
      
    - name: Generate or retrieve encryption key for password storage
      shell: |
        if [ ! -f /var/lib/postgresql/.postgres_encryption_key ]; then
          # Generate a secure random key for encryption
          openssl rand -base64 32 > /var/lib/postgresql/.postgres_encryption_key
          chmod 600 /var/lib/postgresql/.postgres_encryption_key
          chown postgres:postgres /var/lib/postgresql/.postgres_encryption_key
        fi
        cat /var/lib/postgresql/.postgres_encryption_key
      register: encryption_key
      no_log: true
      
    - name: Try to read existing encrypted password from stored file
      shell: |
        if [ -f /var/lib/postgresql/.postgres_password_enc ]; then
          openssl enc -aes-256-cbc -d -salt -pbkdf2 -pass pass:"{{ encryption_key.stdout }}" -in /var/lib/postgresql/.postgres_password_enc 2>/dev/null
        else
          exit 1
        fi
      register: existing_encrypted_password
      failed_when: false
      changed_when: false
      no_log: true
      
    - name: Set existing password if file exists and is valid
      set_fact:
        postgres_password: "{{ existing_encrypted_password.stdout }}"
      when:
        - existing_encrypted_password.rc == 0
        - existing_encrypted_password.stdout is defined
        - (existing_encrypted_password.stdout | length) == 16
      no_log: true
      
    - name: Generate secure PostgreSQL password only if needed (OS-independent method)
      shell: |
        # Primary Method: Python secrets (works on all OS with Python 3.6+)
        python3 -c "
        import secrets
        import string
        # Use cryptographically secure random generator
        uppercase = ''.join(secrets.choice(string.ascii_uppercase) for _ in range(4))
        lowercase = ''.join(secrets.choice(string.ascii_lowercase) for _ in range(4))
        digits = ''.join(secrets.choice(string.digits) for _ in range(4))
        special = ''.join(secrets.choice('!@#\$%^&*') for _ in range(4))
        password = list(uppercase + lowercase + digits + special)
        secrets.SystemRandom().shuffle(password)
        print(''.join(password))
        "
      register: generated_password_primary
      when: postgres_password is not defined
      no_log: true

    - name: Generate secure PostgreSQL password using OpenSSL fallback (Linux/macOS only)
      shell: |
        # Fallback Method: OpenSSL (Linux/macOS optimized)
        openssl rand -base64 24 | tr -d "=+/" | cut -c1-16
      register: generated_password_fallback
      when: 
        - postgres_password is not defined
        - generated_password_primary.failed is defined
        - generated_password_primary.failed == true
      no_log: true
      failed_when: false

    - name: Set password from OS-independent generation
      set_fact:
        postgres_password: "{{ generated_password_primary.stdout if generated_password_primary.stdout is defined else generated_password_fallback.stdout }}"
      when: postgres_password is not defined
      no_log: true
      
    - name: Validate password complexity
      assert:
        that:
          - postgres_password | length == 16
          - postgres_password | regex_search('[A-Z]')
          - postgres_password | regex_search('[a-z]')
          - postgres_password | regex_search('[0-9]')
          - postgres_password | regex_search('[!@#$%^&*]')
        fail_msg: "Generated password does not meet complexity requirements"
        success_msg: "Password meets security requirements"
      no_log: true
      
    # Store password in a fact to ensure consistency throughout playbook
    - name: Store password in host facts for consistency
      set_fact:
        postgres_password: "{{ postgres_password }}"
      no_log: true
      
    # Storage Setup
    - name: Check if device is already mounted
      command: mountpoint -q {{ postgres_mount }}
      register: mount_check
      failed_when: false
      changed_when: false
      
    - name: Format device if not mounted
      filesystem:
        fstype: xfs
        dev: "{{ postgres_device }}"
        force: no
      when: mount_check.rc != 0
      
    - name: Create mount point and mount device
      mount:
        path: "{{ postgres_mount }}"
        src: "{{ postgres_device }}"
        fstype: xfs
        opts: defaults,noatime
        state: mounted
        
    # PostgreSQL Installation - Multi-OS Support
    
    # Ubuntu/Debian Installation
    - name: Install required packages for repository (Ubuntu/Debian)
      apt:
        name:
          - wget
          - ca-certificates
          - gnupg
          - lsb-release
          - python3-bcrypt
          - python3-psycopg2
        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"
    
    # CentOS/RHEL Installation  
    - name: Install PostgreSQL repository (CentOS/RHEL)
      yum:
        name: "https://download.postgresql.org/pub/repos/yum/reporpms/EL-{{ ansible_distribution_major_version }}-x86_64/pgdg-redhat-repo-latest.noarch.rpm"
        state: present
        disable_gpg_check: yes
      when: ansible_os_family == "RedHat"
    
    - name: Install required packages (CentOS/RHEL)
      yum:
        name:
          - postgresql{{ postgres_version }}-server
          - postgresql{{ postgres_version }}
          - python3-bcrypt
          - python3-psycopg2
          - wget
          - ca-certificates
        state: present
      when: ansible_os_family == "RedHat"
    
    # Ubuntu/Debian Repository Setup
    - name: Get Ubuntu codename
      command: lsb_release -cs
      register: ubuntu_codename
      changed_when: false
      when: ansible_os_family == "Debian"
      
    - name: Add PostgreSQL signing key
      apt_key:
        url: https://www.postgresql.org/media/keys/ACCC4CF8.asc
        state: present
      when: ansible_os_family == "Debian"
        
    - name: Add PostgreSQL APT repository
      apt_repository:
        repo: "deb http://apt.postgresql.org/pub/repos/apt {{ ubuntu_codename.stdout }}-pgdg main"
        state: present
      when: ansible_os_family == "Debian"
        
    - name: Update package cache after adding PostgreSQL repo
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"
        
    # Install PostgreSQL (Ubuntu/Debian)
    - name: Install PostgreSQL packages (Ubuntu/Debian)
      apt:
        name:
          - "postgresql-{{ postgres_version }}"
          - "postgresql-client-{{ postgres_version }}"
        state: present
      when: ansible_os_family == "Debian"
    
    # Initialize PostgreSQL on CentOS/RHEL (required step)
    - name: Initialize PostgreSQL database (CentOS/RHEL only)
      command: "/usr/pgsql-{{ postgres_version }}/bin/postgresql-{{ postgres_version }}-setup initdb"
      when: 
        - ansible_os_family == "RedHat"
      become: yes
      register: postgres_init_result
      failed_when: false
      changed_when: postgres_init_result.rc == 0
        
    - name: Store password securely for future runs (after PostgreSQL installation)
      shell: |
        # Create encrypted password file using secure encryption key
        echo "{{ postgres_password }}" | openssl enc -aes-256-cbc -salt -pbkdf2 -pass pass:"{{ encryption_key.stdout }}" -out /var/lib/postgresql/.postgres_password_enc
        chmod 600 /var/lib/postgresql/.postgres_password_enc
        chown postgres:postgres /var/lib/postgresql/.postgres_password_enc
        # Also store a hash for verification
        echo "{{ postgres_password }}" | sha256sum | cut -d' ' -f1 > /var/lib/postgresql/.postgres_password_hash
        chmod 600 /var/lib/postgresql/.postgres_password_hash
        chown postgres:postgres /var/lib/postgresql/.postgres_password_hash
      when: postgres_password is defined
      no_log: true
        
    - name: Stop PostgreSQL for data migration
      systemd:
        name: postgresql
        state: stopped
        
    # Data Migration
    - name: Check if old data directory exists
      stat:
        path: "{{ postgres_old_dir }}/PG_VERSION"
      register: old_data_exists
      
    - name: Check if new data directory is empty
      find:
        paths: "{{ postgres_data_dir }}"
        file_type: any
      register: new_data_check
      failed_when: false
      
    - name: Create new data directory
      file:
        path: "{{ postgres_data_dir }}"
        state: directory
        owner: postgres
        group: postgres
        mode: '0700'
        recurse: yes
        
    - name: Copy data to new location
      shell: |
        sudo -u postgres cp -a {{ postgres_old_dir }}/* {{ postgres_data_dir }}/
        sudo -u postgres cp -a {{ postgres_old_dir }}/.[^.]* {{ postgres_data_dir }}/ 2>/dev/null || true
      when: 
        - old_data_exists.stat.exists
        - new_data_check.matched == 0
        
    - name: Fix permissions on data directory
      file:
        path: "{{ postgres_data_dir }}"
        owner: postgres
        group: postgres
        mode: '0700'
        recurse: yes
        
    # Configuration
    - name: Configure PostgreSQL settings
      lineinfile:
        path: "{{ postgres_config_dir }}/postgresql.conf"
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        backup: yes
      loop:
        - { regexp: '^#?data_directory\s*=', line: "data_directory = '{{ postgres_data_dir }}'" }
        - { regexp: '^#?port\s*=', line: "port = {{ postgres_port }}" }
        - { regexp: '^#?listen_addresses\s*=', line: "listen_addresses = '*'" }
        - { regexp: '^#?max_connections\s*=', line: "max_connections = 1000" }
      notify: restart postgresql
      
    - name: Configure pg_hba.conf for access
      copy:
        dest: "{{ postgres_config_dir }}/pg_hba.conf"
        content: |
          # Database administrative login by Unix domain socket
          local   all             postgres                                peer

          # "local" is for Unix domain socket connections only
          local   all             all                                     peer

          # IPv4 local connections:
          host    all             all             0.0.0.0/0               md5

          # IPv6 local connections:
          host    all             all             ::1/128                 md5

          # Allow replication connections from localhost, by a user with the
          # replication privilege.
          local   replication     all                                     peer
          host    replication     all             127.0.0.1/32            md5
          host    replication     all             ::1/128                 md5
        owner: postgres
        group: postgres
        mode: '0640'
        backup: yes
      notify: restart postgresql
      
    # Start Service
    - name: Start and enable PostgreSQL
      systemd:
        name: postgresql
        state: started
        enabled: yes
        
    # Wait for PostgreSQL to be ready
    - name: Wait for PostgreSQL to be ready
      wait_for:
        port: "{{ postgres_port }}"
        timeout: 30
        
    # Secure Password Setup - Only set if not already configured
    - name: Test if password is already set correctly
      shell: |
        export PGPASSWORD='{{ postgres_password }}'
        psql -h localhost -p {{ postgres_port }} -U postgres -c "SELECT 'Password already configured' as status;" 
      register: existing_password_test
      no_log: true
      failed_when: false
      changed_when: false
      
    - name: Set PostgreSQL postgres user password only if needed
      shell: |
        export PGPASSWORD_NEW='{{ postgres_password }}'
        sudo -u postgres psql -p {{ postgres_port }} <<EOF
        ALTER USER postgres PASSWORD '$PGPASSWORD_NEW';
        EOF
      no_log: true
      register: password_set_result
      when: existing_password_test.rc != 0
      
    - name: Verify password was set successfully (only if password was changed)
      debug:
        msg: "Password configuration completed"
      when: password_set_result is defined and password_set_result.changed
      
    # Reload PostgreSQL configuration
    - name: Reload PostgreSQL configuration
      shell: sudo -u postgres psql -p {{ postgres_port }} -c "SELECT pg_reload_conf();"
      
    # Wait a bit for configuration to take effect
    - name: Wait for PostgreSQL to be fully ready after password change
      wait_for:
        timeout: 5
        
    - name: Test local connection first (using peer authentication)
      shell: |
        sudo -u postgres psql -p {{ postgres_port }} -c "SELECT 'Local peer authentication works' as status;"
      register: peer_test
      
    - name: Test password authentication locally first
      shell: |
        export PGPASSWORD='{{ postgres_password }}'
        psql -h localhost -p {{ postgres_port }} -U postgres -c "SELECT 'Local password authentication works' as status;" 
      register: local_password_test
      no_log: true
      retries: 3
      delay: 2
      until: local_password_test.rc == 0
      
    - name: Test PostgreSQL connection with new password (remote)
      shell: |
        export PGPASSWORD='{{ postgres_password }}'
        psql -h {{ postgres_external_host }} -p {{ postgres_port }} -U postgres -c "SELECT version();" 
      register: pg_test
      no_log: true
      retries: 3
      delay: 2
      until: pg_test.rc == 0
      
    # Verify password consistency before creating Kubernetes files
    - name: Verify password consistency by testing connection again
      shell: |
        export PGPASSWORD='{{ postgres_password }}'
        psql -h {{ postgres_external_host }} -p {{ postgres_port }} -U postgres -c "SELECT 'Password verification successful' as status;" 
      register: password_verification
      no_log: true
      failed_when: password_verification.rc != 0
      retries: 3
      delay: 2
      until: password_verification.rc == 0
      
    # Create Kubernetes Secret and ConfigMap - Always create on localhost
    - name: Create temporary directory for secrets on localhost
      file:
        path: /tmp/postgresql-secrets
        state: directory
        mode: '0755'
      delegate_to: localhost
      run_once: true
      become: false
      
    - name: Generate base64 encoded values for Kubernetes secret
      set_fact:
        postgres_password_b64: "{{ postgres_password | b64encode }}"
      no_log: true
      when: password_verification is defined and password_verification.rc == 0
      
    - name: Create Kubernetes Secret YAML content
      set_fact:
        secret_yaml_content: |
          apiVersion: v1
          kind: Secret
          metadata:
            name: {{ postgres_secret_name }}
            namespace: {{ postgres_namespace }}
          data:
            postgres-password: {{ postgres_password_b64 }}
          type: Opaque
      when: postgres_password_b64 is defined
      
    - name: Create Kubernetes ConfigMap YAML content
      set_fact:
        configmap_yaml_content: |
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: postgres-setup-config
            namespace: postgres
          data:
            postgres-host: {{ postgres_external_host }}
            postgres-port: "{{ postgres_port }}"
      when: postgres_password_b64 is defined
      
    - name: Write Kubernetes Secret YAML to localhost
      copy:
        content: "{{ secret_yaml_content }}"
        dest: /tmp/postgresql-secrets/{{ postgres_secret_name }}.yml
        mode: '0600'
      delegate_to: localhost
      run_once: true
      become: false
      when: postgres_password_b64 is defined
        
    - name: Write Kubernetes ConfigMap YAML to localhost
      copy:
        content: "{{ configmap_yaml_content }}"
        dest: /tmp/postgresql-secrets/postgres-setup-config.yml
        mode: '0644'
      delegate_to: localhost
      run_once: true
      become: false
      when: postgres_password_b64 is defined
            
    # Secure cleanup of temporary files on remote host
    # Final validation - ensure PostgreSQL connection works
    - name: Final password consistency validation
      shell: |
        export PGPASSWORD='{{ postgres_password }}'
        psql -h localhost -p {{ postgres_port }} -U postgres -c "SELECT 'Setup completed successfully' as status;" 
      register: final_validation
      no_log: true
      when: postgres_password_b64 is defined
      
    - name: Clean up any temporary password files (excluding Kubernetes YAML files)
      shell: |
        find /tmp -name "*postgres*" -type f -mmin -5 ! -name "*.yml" -delete 2>/dev/null || true
        find /var/tmp -name "*postgres*" -type f -mmin -5 ! -name "*.yml" -delete 2>/dev/null || true
        # Clear any environment variables that might contain passwords
        unset PGPASSWORD PGPASSWORD_NEW 2>/dev/null || true
      changed_when: false
      failed_when: false
      
    # Clear sensitive variables from memory
    - name: Clear sensitive variables from Ansible facts
      set_fact:
        postgres_password: ""
        postgres_password_b64: ""
        generated_password: ""
        generated_password_primary: ""
        generated_password_fallback: ""
      no_log: true
      
    # Verify Kubernetes files were created
    - name: Verify Kubernetes files were created successfully on localhost
      stat:
        path: "{{ item }}"
      register: k8s_files_check
      loop:
        - /tmp/postgresql-secrets/{{ postgres_secret_name }}.yml
        - /tmp/postgresql-secrets/postgres-setup-config.yml
      delegate_to: localhost
      run_once: true
      become: false
      when: postgres_password_b64 is defined
      
    - name: Display Kubernetes files status
      debug:
        msg: |
          Kubernetes Files Status:
          {% for file in k8s_files_check.results %}
          - {{ file.item }}: {{ 'EXISTS' if file.stat.exists else 'MISSING' }}
          {% endfor %}
      when: k8s_files_check is defined
      
    # Final verification and summary
    - name: Display setup summary
      debug:
        msg: |
          âœ… PostgreSQL {{ postgres_version }} Secure Setup Complete
          
          Configuration:
          - Host: {{ ansible_host }}
          - Port: {{ postgres_port }}
          - Data Directory: {{ postgres_data_dir }}
          - Mount Point: {{ postgres_mount }}
          - Password: {{ 'REUSED EXISTING' if existing_password_test.rc == 0 else 'NEWLY GENERATED' }}
          - Password Storage: /var/lib/postgresql/.postgres_password_enc (AES-256-CBC encrypted)
          - Connection Test: {{ 'PASSED' if pg_test is succeeded else 'FAILED' }}
          
          Kubernetes Files Generated:
          - Secret: /tmp/postgresql-secrets/{{ postgres_secret_name }}.yml
          - ConfigMap: /tmp/postgresql-secrets/postgres-setup-config.yml
          
          Security Features:
          - 16-character secure password (persistent across runs)
          - AES-256-CBC encrypted password storage with PBKDF2
          - Cryptographically secure encryption key (randomly generated)
          - MD5 authentication for database connections
          - No plaintext passwords in logs or process lists
          - Environment variable isolation
          - Secure memory cleanup
          - Private subnet deployment
          - Idempotent execution
          - Kubernetes secrets with proper encoding
          
          Next Steps:
          1. Review files in /tmp/postgresql-secrets/
          2. Deploy to Kubernetes cluster
          3. Password will be reused on subsequent playbook runs
          
          Note: Password is securely encrypted with a randomly generated key stored at:
          /var/lib/postgresql/.postgres_encryption_key
          
  handlers:
    - name: restart postgresql
      systemd:
        name: postgresql
        state: restarted
